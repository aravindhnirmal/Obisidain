This guide consists of several subsections: my background, introductory steps, practice resources, study resources, practice methods, and answering common questions about competitive programming.

**My Background and Disclaimers:**

A quick disclaimer: I am not some genius competitive programmer. In fact, I consider myself to be beginner/intermediate, given that I have been doing it for < 10 months in total now (not continuously - I stopped for a year and a half in between, doing no programming during this time). So, by no means am I an expert on this topic - if anyone feels like I have missed something in this guide (which I certainly have), do leave a comment! That being said, I think that I'm a good person to be writing this guide because **when I started competitive programming, I had zero knowledge of programming and virtually no math background.** Many successful competitive programmers you will come across have been coding from a young age and/or doing math competitions (e.g., IMO) for years prior to starting, and so trying to follow what they did to "get good" will probably just not work for you (unless you share such a background).

But chances are, if you are reading this, you know some programming and/or math, and so pretty much everything I mention here will be either applicable to you or beneath you (so to speak). I guess I should prove that these techniques worked for me - using them, I was able to go from zero to Google Kickstart top 50, winning prizes, placing first/second nationally in big competitions, ICPC, etc. in not too long. (Not tying to flex at all - actually, my achievements aren't anything impressive compared to other competitive programmers - it's just that these sort of posts usually contain something like this)

Another disclaimer: **I do not mention USACO anywhere in this blog**. The reason: I simply have never used it. I have heard some excellent things about it, though, so if anyone would like to add USACO-specific comments, please do!

**So, how do I start? And what is competitive programming?**

Before you read any further, watch this [video](https://www.youtube.com/watch?v=bVKHRtafgPc) from William Lin if you haven't already. It's great at answering questions you may have, and William also goes over his tips for beginners. So what's the purpose of this post then? Well, the video is a bit outdated in my opinion - I have some stuff to add. Also, William can be classed as one of those "competitive programming geniuses" I mentioned earlier. There is also this [video](https://www.youtube.com/watch?v=xAeiXy8-9Y8), by another YouTuber called Errichto, that I also recommend.

After you've watched the video(s), there's one thing I want to add right off the bat - **don't focus on typing speed** as a beginner. It's simply not important if you're starting out - solving problems is much, much more worth your time at this stage, in my opinion. There are Legendary Grandmasters (LGMs on Codeforces - more on this platform later) who type with two fingers, after all. I am not going to elaborate more on what competitive programming is, what big competitive programming contests there are, etc. as these are all either Google-able questions or have been answered in the videos linked above. As for my thoughts on how to start competitive programming, keep reading...

**Practice Resources**

Let's now get into resources you can use to practice (ie solve problems). Interestingly, everyone says the same thing - **when you start off, it does not matter what resource you use**. At the beginning, you are still developing basic competences and learning basic techniques, and so the platform you use doesn't matter as long as its a decent one (and one with easy problems, of course). William mentions Hackerrank in his video. Other people use HackerEarth, Codechef, or LeetCode even.

But I want to talk a bit about the two platforms that have helped me the most (and probably the two biggest platforms at the moment) - Codeforces and AtCoder. I am sure many of you have heard of Codeforces, and what William says about it and how to use it is great. So, I will speak about AtCoder in more depth - I think it is a brilliant platform. The great thing about it is it's **immediately accessible**. Yes, you, reading this, if you know just a tiny bit of a programming language, you can go the [AtCoder website](https://atcoder.jp/), pick an ABC (AtCoder Beginner Contest), and have a good shot at solving the first two problems, which are designed to be accessible to everyone. If you can't, read the editorial. Rinse and repeat (more about this method is to come in the "How to Practice" section), solving all problems that you can each time, and you'll quickly see improvement.

Once ABCs become too easy, move onto ARCs (AtCoder Regular Contests), and then to AGCs. Of course, just like Codeforces, these contests are hosted by AtCoder - meaning you can compete in them! And just like that, you can rapidly improve at competitive programming without even really realising it, and even enjoying the competitive aspect of it. **Note** that you can also use Codeforces in a similar way, but I particularly like that AtCoder has very easy problems to allow people with no experience to dive straight into competitive programming.

There are many other online judges (websites you can solve problems, submit code, and get instant feedback), such as DMOJ, SPOJ, and Kattis. These sites have a variety of problems and also often allow you to sort problems by difficulty/number of solves, as William demonstrates in his video with Codeforces. You can try them all out, see which problems you like the most perhaps, but I recommend sticking to one when you're starting out. For example, many Japanese competitive programmers have only used AtCoder in their competitive programming journey.

**Study Resources**

Great - now we know about many platforms that exist for you to solve problems/compete on, and we also have a rough idea of a solid practice routine. However, there is one key aspect of competitive programming that deserves to be explored in more depth: how to learn new concepts. As you improve, you will very quickly come across unfamiliar topics, and it's essential that you tackle that unfamiliarity in a suitable manner - when you come across a DFS problem for the first time, should you buy a book on Graph Theory and spend a month learning it all? Obviously not. I am now going to share some resources for studying (or more accurately, learning) and what you _should_ do in such a situation.

There is one learning resource that stands out above the rest, in my opinion. It is the Competitive Programmer's Handbook, by CSES - [link](https://cses.fi/book/book.pdf). It is completely free, and covers pretty much everything any beginner/intermediate competitive programmer needs to know. It includes implementations and proofs, as well explanations of the intuition behind solutions. I cannot recommend this enough. Take our situation from earlier - when you come across the term DFS, simply look it up in the handbook, read the section, and you're done! (You'll also want to solve some problems on it to test/refine your understanding - more on this later) Another great thing about this resource is that it goes through topics in a good order. So, you can literally just read through it, if you so desire. There are, of course, other great resources to improve your competitive programming knowledge - one of which being, as you might expect, YouTube videos.

[Errichto](https://www.youtube.com/@Errichto), who I have mentioned already, makes fantastic educational videos. He made an entire series on Dynamic Programming, a fundamental concept, which helped me enormously. [SecondThread](https://www.youtube.com/@SecondThread) has also made some great beginner-level content, and I personally enjoy [Algorithms Live](https://www.youtube.com/@AlgorithmsLive)'s videos (but they may be a bit less accessible to newbies).

There's another amazing resource I want to highlight that goes hand-in-hand with the previous paragraph, and that is Codeforces blogs. Codeforces, which is indeed a contest-hosting platform, is also the largest _community_ of competitive programmers in the world. If you come across a topic/technique you want to learn, just add "codeforces" to your Google search, and it's likely several resource list/tutorial blogs will come up.

For example, say I have tried to solve a problem for a while, and gave up. I read the editorial, which mentions using the "_Convex Hull Trick for Dynamic Programming_". I think to myself, what on earth is that? Many people of my rating solved this problem, so I should really be ale to solve it myself! Let me go learn it! All I have to do is search up "_convex hull trick codeforces_" in Google - and bam, there are pages of search results with tons of useful material _specifically_ about using this trick in competitive programming (see for yourself!). I can even search up "_convex hull trick_ _**problems**_ _codeforces_" - clicking on the very first Codeforces blog that comes up, and scrolling down, I see a whole bunch of previously seen competitive programming problems linked that I can use to practice _this very technique_. And bear in mind, this specific algorithm is _not at all a beginner topic!_ Imagine if it was an easier topic that I was searching for!

There's one final resource which I'd briefly like to touch on, that you could say I have a bias for. It's a textbook used in MIT and several other institutions, known as Introduction to Algorithms. Its authors have initials C, L, R and S, and thus is often also called CLRS. Interestingly, it's additionally known as The Bible, which should already indicate how great of a resource it is! I like it because not only does it describe algorithms and provide implementations, but proves correctness and explains the mathematics underlying them. Objectively though, it is **massive overkill** for competitive programming - it's over a thousand pages long, and if you buy it, like I did, it will set you back quite a bit. The reason I wanted to mention it is that it's a superb resource if you are interested in algorithms/problem solving/math in general, and I can say with confidence that even if I hadn't persisted with competitive programming, it'd still be worth every penny.

**How to Practice/Improve**

OK, let's now formalise a practice routine, and start to bring everything together. I, and many others, recommend the following - solve problems that are slightly challenging for you (say, 0 - 200 points above your rating on Codeforces) (using the **Practice Resources**). When you are starting out, if you cannot solve a problem within, say, twenty minutes - stop (there's a good chance a technique is required that you are not familiar with). Then, read the editorial, go learn the technique (using the **Study Resources**) and solve problems on that technique, if it uses a technique you don't know. If it doesn't, fully digest the editorial, understand the logic behind it, and **up-solve the problem**. This (in most cases) means to solve a problem you couldn't solve after reading (some or all of) its solution, and is crucial, especially when you are starting out and lack implementation skills.

There's another similar technique, that I have heard that even Grandmasters still use - simply pick a problem difficulty (e.g., 200 points above your current Codeforces rating), filter all problems down to those corresponding to that difficulty, and solve all of them, reading editorials, learning and up-solving where you see fit. Then, compete in contests to get to that rating, and repeat the process. **Note** however that you should not follow this exact method if you are a beginner, because there will simply be too many problems of a low difficulty for you to solve them all!

Now, there's one key point here that I've just sort of skimmed over - competition! It is competitive programming, after all. If contests didn't exist, what would be the point? Platforms like Codechef, Codeforces and AtCoder hold contests and have a rating system, which is a HUGE motivator to improve and practice. If you're starting out, for example, set yourself the following challenge - every time you compete in an AtCoder contest, try and do better (get a higher rank) than the last contest. Alternatively, if you have friends that do competitive programming, try and get to a higher rating than them! Or, challenge yourself to get to, say, Expert, or Candidate Master, or even Specialist/Pupil (if you're just starting out) on Codeforces. Simply competing in contests, then up-solving the problems you didn't solve, is yet another excellent practice routine, which often doesn't even feel like practice at all. In fact, as I touched on earlier, because of the accessibility of AtCoder Beginner Contests, you can solely use this practice method with ABCs, which can make the process interesting and enjoyable. Note that **virtual participation** is a thing - essentially, you can compete in a contest you haven't done before _as if you were in the contest itself_. It's supported on Codeforces and AtCoder, and probably many more platforms. Thus, if there is no ongoing contest or you don't want to risk losing rating, you can still feel like you're competing.

There's one final practice/improvement resource I'd like to cover that can really deepen your understanding of theory, and allow you to solve more/harder problems. This is the [CSES problem set](https://cses.fi/problemset/). The astute among you will realise that CSES has already been mentioned - they made the handbook! This problem set goes hand-in-hand with it, actually, and provides practice problems for the topics mentioned in the book! This way, when you read a section of the book, you can solve problems on it, and be better prepared when problems on those topics come up in contests.

**An anecdote about improvement and practice:**

So far, I've sort of just thrown information and practice methods at you. I'm now going to explain how I overcame a big hurdle that was preventing me from improving, to demonstrate that the methods I've described so far can facilitate your competitive programming journey.

As I mentioned at the very beginning of this post, I started competitive programming with very little CS/math background knowledge. I started solving problems and gaining rating, which was great. I was really drawn to the more programming-y problems, involving greedy algorithms, DP, graphs, data structures, etc., and so solved a lot of problems on these topics. However, I soon realised something - I was _terrible_ at math problems. Math is very important in competitive programming - specific areas of math, to be more accurate, as William Lin explains in his video. I would constantly come across low-rated (easy) problems that I would really struggle with simply because they were math. This was a huge problem for me, and cost me a lot of rating points. It got to the point where I was able to implement Segment Trees, but did not know about the Triangle Inequality (yes, when I said I had virtually no math background, I was not joking!).

So, when I had some free time, I simply did the following - pretty much every day, for nearly two weeks, I would pick a random AtCoder Beginner Contest I hadn't done before (there is a great [website](https://kenkoooo.com/atcoder) that lets you see which AtCoder problems and contests you haven't solved), and force myself to solve until Problem F. Note that I did this because **AtCoder is an extremely mathematical programming platform**. It is not at all uncommon for an AtCoder problem statement to simply be "Evaluate this function:", followed by some long math expression.

While solving the contest's problems, if I couldn't solve a problem after around an hour of thinking (sometimes, I gave myself up to 3 hours for the Problem Fs), only then would I read the editorial, and even then, I would make sure I understood it, no matter how long it took. If it was a topic, such a combinatorial technique I wasn't familiar with, I would use the **Study Resources** I've described earlier to learn it, then up-solve the problem after. After doing this for a couple of weeks, I was amazingly no longer terrible at math! Interestingly, now, some of my strongest topics are math-related, something I would have never dreamt of. Even more interestingly, months after doing this "training" (if you can call it that), I saw a Codeforces [blog post](https://codeforces.com/blog/entry/103077), where the author, a Grandmaster, explained that he used almost an identical method to improve at math problems!

**I will now go over some commonly asked questions, and my responses to them.**

**1) Do I need to study DSA beforehand?**

The short answer: no. Solve problems, learn the DSA stuff when you come across a problem that requires it, and then solve problems on that topic (a recurring theme in this post!). This prevents you from spending hours trying to understand a DS/A you are just too inexperienced to understand.

Of course, if you are interested in DSA in general, feel free - it won't hurt, of course, and can only help your future self. But, for sure, if you dive right in, you will soon come across a beginner-level DSA concept, such as prefix sums or binary search while solving problems. And so, you will inadvertently be learning DSA at a pace that suits you!

**2) What programming language to learn?**

Now, this is a lot more controversial. I don't think there is a right answer. Objectively, C++ is the best. Its standard library, speed, paired with the simple fact that most competitive programmers use it, makes it unparalleled. But is it worth going out of your way to learn a new language just for competitive programming? Or is it worth learning such a hard language from scratch? Honestly, it's up to you. If you're just starting out, you can just use the language you know best. Often, competitive programmers start with Java or Python, and later switch to C++. So, the choice you make now isn't all too important.

Do your research on your language of choice - if it is semi-popular (e.g. Java, Python), think well before going out of your way to learn a new one (although, as mentioned earlier, you don't need that much C++ for competitive programming). If you don't know any language, I'd say go with C++ - you can be confident it will serve you well and you won't have to ever switch in the future. But, those are just my two cents - there are probably hundreds of blogs/videos about this question, maybe check out others' POV before making a decision on what language to learn.

As a final note, Python is often considered far worse than C++ and Java for competitive programming, but a [Python programmer](https://codeforces.com/profile/conqueror_of_tourist) has recently become a LGM on Codeforces. Probably though, choose a language from these three (they are by far the most popular), but which one you choose among them is not nearly as important as your ability to solve problems - I think everyone will agree with me on that.

**3) (I've decided to learn / I'm considering learning) C++, but I don't know anything right now.How should I learn it?**

This is an extremely pertinent question, that I think I am capable of answering well given that I knew no programming (let alone C++) before doing competitive programming.

My main response may seem counter-intuitive: **DO NOT BUY A C++ BOOK/COURSE**. The C++ that is required for competitive programming is a very specific **subset** of the language itself. For example, **not once have I EVER had to even think about memory management in competitive programming**. Also, **not once have I EVER had to use inheritance or similar OOP concepts in competitive programming**. All C++ programmers appreciate how crucial memory management and OOP is to the language, and for sure, any good book or course you take **will** go into those two aspects, most likely in some depth. This will be **almost completely useless** to you in competitive programming - it's simply not worth your money. To give yet another example, I was watching a live-stream by a top competitive programmer who mentioned that **they do not understand pointers and references in C++**. So, you don't even need to understand what a pointer is for competitive programming, but it is imperative that you have a deep understanding of the algorithmic parts of the STL? Good luck finding a course/book that follows such a layout!

Of course, you can pick and choose the parts that you think are relevant, but I instead recommend a different way of learning the language, and this is what I did. First off, learn the basics. Learn how functions work, variables, types, etc. In fact, most of you reading this post will already know all of this. But if you don't, (and even if you do, just to be sure) find a YouTube video/beginner-level course that explains the absolute basics. I am not going to go in any more depth on how to learn basic C++, as I am sure there are hundreds of resources on this topic.

Once you know some of the basics, I'd say also read some of the handbook (as you've probably realised, I'm a huge fan of this resource), which will also teach you some essential features of the language required for competitive programming (STL, overflow, etc). During this time, you can also start solving problems. As you solve problems, make sure to **look at the top competitors' code/editorial code**, as doing so will gradually expose you to the C++ features required for competitive programming. For example, you may look at the top seed's code on a sorting problem and see how they sorted a std::vector based on a custom comparator, how they used std::priority_queue to implement Dijkstra's Algorithm, or that they a built-in function, "std::lower_bound", to arrive at a simple solution. If you don't understand a specific function or container, for example, Google it and/or look at the reference docs. Once again, we see the common theme of learning a certain aspect as of when you need it, which I am a big advocate for as it prevents you from learning useless information. (Of course, if you are interested in learning C++ in general, do indeed buy a book/course and learn stuff you want to learn about - in this response, I am primarily addressing those who want to learn C++ _solely_ to use for competitive programming.)

If you are struggling with writing C++ or implementation, it goes without saying that you should practice writing C++ and implementation! I found it helpful to pick some easy competitive programming problems, and try to solve them as quickly as I could. This definitely improved my command of the language and my ability to implement solutions quickly, both of which are essential to competitive programming.

**Final Notes**

Firstly, I'd like to quickly give a shout-out to [this post](https://www.reddit.com/r/csMajors/comments/yvgor9/guide_how_to_actually_get_good_at_leetcode/), which inspired me to write this one.

Secondly, please note that there are several posts just like this one which you find useful. You can find ones written by top competitive programmers, such as [this one](https://codeforces.com/blog/entry/53341), [this one](https://codeforces.com/blog/entry/91114), or [this one](https://codeforces.com/blog/entry/98806), and also ones written by more "average" competitive programmers, on Codeforces. It may be that you share a more similar background with others than you do with me, and so learning about their journeys and practice routines might be more useful.

Thirdly, there was actually another question that I had planned to answer, "Why should I even do/persist with competitive programming? ", but this post is already long enough as it is. If anyone is interested, I can certainly write another post with my thoughts on this question.

One final thing - **please leave any questions/comments you may have** _**on this post,**_ **instead of PM-ing me about it**! That way, others will also be able to see/respond.

If you've made it this far, thank you for reading! I realise this post is extremely unorganised; I apologise for this, and for any grammatical errors I have undoubtedly made. Hopefully, you were still able to take away something of value :).